// First level: 1. Даны два целых числа x и n, напишите функцию для вычисления x^n
//      решение 1 - рекурсивно O(n)
//      решение 2 - улучшить решение 1 до O(lon n)

function sqr(x, n) {
    return n===1 ?  1 : x * sqr(x, n-1);
}

console.log(sqr(4, 3));




//     Имея два отсортированных массива размера m и n соответственно, вам нужно найти элемент, который будет находиться на k-й позиции в конечном отсортированном массиве.
//     Массив 1 - 100 112 256 349 770
//     Массив 2 - 72 86 113 119 265 445 892
//     к = 7
//     Вывод : 256
//     Окончательный отсортированный массив -
//     72, 86, 100, 112, 113, 119, 256, 265, 349, 445, 770, 892
//     [0] [1] [2]  [3]  [4]  [5]  [6]  [7]  [8]  [9]  [10] [12]
//     7-й элемент этого массива равен 256. ?

const arr1 = [100, 112, 256, 349, 770]
const arr2 = [72, 86, 113, 119, 265, 445, 892]

function findk(m, n, k) {
    let i = 0; // переменные индексов массива
    let j = 0;

    while (k > i + j) {      // пока сумма индексов двух массивов меньше искомого индекса
        if (m[i] < n[j]) {   // сравнение элементов двух массивов
            i+=1;            // если элемент первого массива меньше то переходим на след элемент массива m
        }else {
            j+=1;            // если элемент первого массива больше то переходим на след элемент массива n
        } 
    }

    return m[i] < n[j] ? m[i] : n[j]; 
}

console.log(findk(arr1, arr2, 7)); // элемент под 7 индексом будет 265







//     Имея отсортированный массив arr[] и число x, напишите функцию, которая подсчитывает вхождения x в arr[]. 
//     Ожидаемая временная сложность O(Log n)
//     arr[] = {1, 1, 2, 2, 2, 2, 3,} 
//     x = 2
//     Вывод: 4 раза


function countXinArr(arr, x) {

    let count = 0;

    for (let i = 0; i < arr.length; i++) {

        x === arr[i] ? count +=1 : count += 0
        
    }

    return `${count} раза`

}

let arr = [1, 1, 2, 2, 2, 2, 3]
console.log(countXinArr(arr, 2));

// попытка попробовать через бинарный поиск свести к log(n), но тщетно( Покажите решение на занятии пжл

// function binarySearch(arr, x) {
//     let m_idx = Math.floor(arr.length / 2);
//     console.log('Search in: ' + arr);

//     if (arr[m_idx] == x) {
//         return arr[m_idx];
//     } else if (x < arr[m_idx]) {
//         return binarySearch(arr.slice(0, m_idx) , x);
//     } else {
//         return binarySearch(arr.slice(m_idx+1), x);
//     }
// }

// console.log(binarySearch([1, 3, 5, 6, 7, 10, 13, 16, 20, 22, 34, 37], 3));







// 4* Найдите пиковый элемент в двумерном массиве
// Элемент является пиковым, если он больше или равен своим четырем соседям слева, справа, сверху и снизу. Например, соседями для A[i][j] являются A[i-1][j], A[i+1][j], A[i][j-1] и A[i][j+1 ]. Для угловых элементов отсутствующие соседи считаются отрицательными бесконечными значениями.
// 10 20 15
// 21 30 14
//  7 16 32
// Выход: 30
// 30 — пиковый элемент, потому что все его
// соседи меньше или равны ему.
// 32 также можно выбрать в качестве пика.

// note
// 1 Смежная диагональ не считается соседней. 
// 2 Пиковый элемент не обязательно является максимальным элементом. 
// 3 Таких элементов может быть несколько. 
// 4 Всегда есть пиковый элемент.

let arrayM = [[10, 20, 15],
              [21, 30, 14],
              [7, 16, 32]];


function find (array){
    for (let i = 0; i < array.length; i++) {
        for (let j = 0; j < array[i].length; j++) {

            if ((i-1 < 0 || array[i][j] > array[i-1][j]) && // (i-1 < 0 (получим true) || эта часть не будет выполняться, [i-1]---вернет -1 
                (j-1 < 0 || array[i][j] > array[i][j-1]) &&
                (j+1 == array.length || array[i][j] > array[i][j+1]) && // (j+1 == array.length (j+1 будет конечным элементом массива)
                (i+1 == array.length || array[i][j] > array[i+1][j])) {

                console.log(array[i][j]);
                
            } 
            
        }
        
    }
}

find(arrayM)